package main

import (
	"errors"
	"fmt"
	"os"
	"path/filepath"
)

func main() {
	filePath := "test.txt"

	extractedText, err := processFile(filePath)
	if err != nil {
		fmt.Printf("Error processing file: %v\n", err)
		return
	}

	fmt.Printf("Original Content: %s", extractedText)

	// simulate gemini response
	response, err := simulateGemini(extractedText)
	if err != nil {
		fmt.Printf("Error generating response: %v\n", err)
		return
	}
	fmt.Println("\nSimulated Gemini Response:")
	fmt.Println(response)
}

func processFile(filePath string) (string, error) {
	fileExtension := filepath.Ext(filePath)
	switch {
	case fileExtension == ".txt":
		return readFile(filePath)
	case fileExtension == ".pdf":
		return readPDF(filePath)
	default:
		return "", fmt.Errorf("unsupported file type: %s", fileExtension)
	}
}

// readFile reads the file given in input as arg (filePath)
func readFile(filePath string) (string, error) {
	content, err := os.ReadFile(filePath)
	if err != nil {
		return "", fmt.Errorf("readFile: error reading file '%s': %w", filePath, err)
	}
	return string(content), nil
}

func readPDF(pdfPath string) (string, error) {
	return fmt.Sprintf("Text extracted from PDF (%s)", pdfPath), nil
}

// simulateGemini returns the output generated by gemini
func simulateGemini(input string) (string, error) {
	if input == "" {
		return "", errors.New("simulateGemini: input can not be empty")
	}
	return fmt.Sprintf("Simulated Summary: This document contains the following information: %s", input), nil
}
